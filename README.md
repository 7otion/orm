# 7otion ORM

Simple, type-safe, database-agnostic TypeScript ORM with Active Record pattern.

## Features

- üîå **Database Agnostic** - Works with any database through adapters
- üöÄ **Active Record Pattern** - Intuitive model-based API
- üîó **Relationships** - HasOne, HasMany, BelongsToMany with eager/lazy loading
- üå≥ **Nested Relationships** - Support for `with('category.contentType')` dot notation
- üíæ **Smart Caching** - Automatic relationship cache management
- üîÑ **Transactions** - Full transaction support with nested transactions
- üìù **Query Builder** - Fluent, chainable query interface
- ‚ö° **SQLite Optimized** - Built-in write queue for SQLite concurrency
- ‚ö° **Tauri SQL Plugin Adapter**

## Installation

```bash
bun add https://github.com/7otion/orm
```

### Optional Dependencies

For Tauri applications:
```bash
bun add @tauri-apps/plugin-sql
```

## Quick Start

### 1. Initialize ORM

```typescript
import { ORM, TauriAdapter, SQLiteDialect } from '7otion-orm';

await ORM.initialize({
  adapter: new TauriAdapter({
    database: 'sqlite:myapp.db',
    debug: true // Optional: log SQL queries
  }),
  dialect: new SQLiteDialect(),
  enableWriteQueue: true // Required for SQLite
});
```

### 2. Define Models

```typescript
import { Model, HasMany, HasOne, BelongsToMany } from '7otion-orm';

class User extends Model<User> {
  static config = {
    // table: 'users', // Optional - auto-derived from class name
    primaryKey: 'id',
    timestamps: true
  };

  // Declare relationship properties for TypeScript
  posts!: Post[];
  profile!: Profile | null;
  roles!: Role[];

  // Define relationships - auto-inferred keys!
  static readonly relationships: Record<string, any> = {
    posts: this.hasMany(Post),           // foreignKey = 'user_id'
    profile: this.hasOne(Profile),       // foreignKey = 'user_id'
    roles: this.belongsToMany(Role, 'user_roles')  // auto-infers keys
  };
}

// Access relationships (auto-generated by Proxy)
const user = await User.find(1);
const posts = user.posts;    // TypeScript knows it's Post[]
const profile = user.profile; // TypeScript knows it's Profile | null
  }
}

class Post extends Model<Post> {
  static config = {
    timestamps: true
  };
}

class Profile extends Model<Profile> {}

class Role extends Model<Role> {}
```

## Usage

### Creating Records

```typescript
// Method 1: Create and save
const user = new User();
user.name = 'John Doe';
user.email = 'john@example.com';
await user.save(); // Auto-detects INSERT

// Method 2: Create in one call
const user = await User.create({
  name: 'John Doe',
  email: 'john@example.com'
});
```

### Reading Records

```typescript
// Find by ID
const user = await User.find(1);

// Get all records
const users = await User.all();

// Query with conditions
const activeUsers = await User.query()
  .where('status', 'active')
  .where('age', '>', 18)
  .orderBy('created_at', 'desc')
  .limit(10)
  .get();

// Get first match
const user = await User.query()
  .where('email', 'john@example.com')
  .first();
```

### Updating Records

```typescript
const user = await User.find(1);
user.name = 'Jane Doe';
await user.save();
```

### Deleting Records

```typescript
const user = await User.find(1);
await user.delete();
```

You can also delete via the query builder when you don't have a
specific instance:

```typescript
// remove all inactive users
await User.query().where('status', 'inactive').delete();

// delete with join/limit if your dialect supports it
await Post.query().join('INNER', 'comments', 'comments.post_id', '=', 'posts.id')
  .where('comments.spam', true)
  .limit(5)
  .delete();
```

### Dirty Tracking

```typescript
const user = await User.find(1);
user.name = 'Jane';
user.email = 'jane@example.com';

console.log(user.isDirty); // true
console.log(user.getDirty()); // ['name', 'email']
console.log(user.getChanges()); 
// { name: { old: 'John', new: 'Jane' }, email: { old: 'john@...', new: 'jane@...' } }

await user.save();
```

## Relationships

### Defining Relationships

```typescript
class User extends Model<User> {
  // STEP 1: Declare relationship properties for TypeScript
  posts!: Post[];
  profile!: Profile | null;
  roles!: Role[];

  // STEP 2: Define relationships - keys auto-inferred!
  static readonly relationships: Record<string, any> = {
    // One-to-many (auto-infers foreignKey = 'user_id', localKey = 'id')
    posts: this.hasMany(Post),
    
    // One-to-one (auto-infers foreignKey = 'user_id', localKey = 'id')
    profile: this.hasOne(Profile),
    
    // Many-to-many (auto-infers foreignKey = 'user_id', relatedKey = 'role_id')
    roles: this.belongsToMany(Role, 'user_roles')  // only pivot table needed!
  };
}

// Override keys when needed
class Post extends Model<Post> {
  author!: User | null;
  
  static readonly relationships: Record<string, any> = {
    author: this.hasOne(User, 'author_id', 'id')
  };
}
```

  get posts() {
    return this.getWithSuspense<Post[]>('posts');
  }

  get profile() {
    return this.getWithSuspense<Profile | null>('profile');
  }

  get roles() {
    return this.getWithSuspense<Role[]>('roles');
  }
}
```

### Accessing Relationships

```typescript
// Lazy loading (loads on access)
const user = await User.find(1);
const posts = user.posts; // Loads automatically

// Eager loading (loads upfront)
const users = await User.query()
  .with('posts', 'profile', 'roles')
  .get();

users[0].posts;   // Already loaded
users[0].profile; // Already loaded
users[0].roles;   // Already loaded

// Nested relationships (loads relationships of relationships)
const posts = await Post.query()
  .with('category.contentType', 'author.profile')
  .get();

posts[0].category;        // Already loaded
posts[0].category.contentType; // Already loaded (nested)
posts[0].author.profile;  // Already loaded (nested)
```

### Cache Management

Relationships are automatically cleared when a model is updated:

```typescript
const user = await User.find(1);
user.name = 'Updated';
await user.save(); // Auto-clears all cached relationships

// Manual operations
user.clearRelationships(); // Clear cache
await user.refresh();      // Reload from database + clear cache
```

## Query Builder

### Basic Queries

```typescript
User.query()
  .where('status', 'active')
  .where('age', '>', 18)
  .where('role', 'IN', ['admin', 'moderator'])
  .orderBy('created_at', 'desc')
  .limit(10)
  .offset(20)
  .get();
```

### Joins

```typescript
User.query()
  .innerJoin('posts', 'posts.user_id', '=', 'users.id')
  .where('posts.published', true)
  .get();
```

### Raw Queries

```typescript
User.query()
  .whereRaw('age > ? AND status = ?', [18, 'active'])
  .get();
```

## Transactions

```typescript
await ORM.transaction(async () => {
  const user = await User.create({
    name: 'John Doe',
    email: 'john@example.com'
  });

  await Post.create({
    user_id: user.id,
    title: 'My First Post',
    content: 'Hello World'
  });

  // Auto-commits on success
  // Auto-rolls back on error
});
```

Nested transactions are supported - only the outermost transaction commits/rolls back.

## Table Name Convention

Table names are automatically derived from model class names:

- `User` ‚Üí `users`
- `BlogPost` ‚Üí `blog_posts`
- `Category` ‚Üí `categories`

Override with `static config`:

```typescript
class User extends Model<User> {
  static config = {
    table: 'custom_users'
  };
}
```

## Timestamps

Enable automatic `created_at` and `updated_at` timestamps:

```typescript
class User extends Model<User> {
  static config = {
    timestamps: true
  };
}
```

Custom timestamp columns:

```typescript
class User extends Model<User> {
  static config = {
    timestamps: {
      created_at: 'createdAt',
      updated_at: 'updatedAt'
    }
  };
}
```

## Creating Custom Adapters

Implement the `DatabaseAdapter` interface:

```typescript
import { DatabaseAdapter, DatabaseRow, QueryValue } from '7otion-orm';

export class MyAdapter implements DatabaseAdapter {
  async query(sql: string, params?: QueryValue[]): Promise<DatabaseRow[]> {
    // Execute SELECT query
  }

  async execute(sql: string, params?: QueryValue[]): Promise<number> {
    // Execute INSERT/UPDATE/DELETE
    // Return affected rows
  }

  async insert(sql: string, params?: QueryValue[]): Promise<number> {
    // Execute INSERT
    // Return last inserted ID
  }

  async beginTransaction(): Promise<void> {}
  async commit(): Promise<void> {}
  async rollback(): Promise<void> {}
  inTransaction(): boolean { return false; }
}
```

## Creating Custom Dialects

Implement the `SqlDialect` interface. two helpers related to deletes are
provided:

* `compileDelete(table, primaryKey, id)` is meant for the
  persistence mixin; the ORM passes it a table and a primary key value
  when you call `someModel.delete()`.
* `compileDeleteQuery(query)` is used by `QueryBuilder.delete()` and
  must handle arbitrary WHERE clauses, joins, limits, etc.  Most of the
  time you can copy the logic from `compileSelect` and simply start with
  `DELETE FROM` instead of `SELECT`.

Example implementation:

```typescript
import { SqlDialect, QueryStructure, CompiledQuery } from '7otion-orm';

export class MyDialect implements SqlDialect {
  compileSelect(query: QueryStructure): CompiledQuery {
    // Build SELECT query
    return { sql: '...', bindings: [...] };
  }

  compileInsert(table: string, data: Record<string, any>): CompiledQuery {
    // Build INSERT query
  }

  compileUpdate(table: string, data: Record<string, any>, primaryKey: string, id: any): CompiledQuery {
    // Build UPDATE query
  }

  // simple single‚Äërow delete used by instance.delete()
  compileDelete(table: string, primaryKey: string, id: any): CompiledQuery {
    return { sql: `DELETE FROM ${table} WHERE ${primaryKey} = ?`, bindings: [id] };
  }

  // full query builder delete ‚Äì reuses the QueryStructure
  compileDeleteQuery(query: QueryStructure): CompiledQuery {
    let sql = `DELETE FROM ${query.table}`;
    // ...similar to compileSelect but using DELETE semantics...
    return { sql, bindings: [] };
  }

  getCurrentTimestamp(): string {
    return 'CURRENT_TIMESTAMP'; // Database-specific
  }
}
```

The ORM ships with a few dialects (SQLite, Postgres, etc.) as examples.
You only need to implement `compileDeleteQuery` if you intend to use the
builder‚Äôs `.delete()` method‚Äîotherwise the simple `compileDelete` is
all that‚Äôs required.

## License

MIT
